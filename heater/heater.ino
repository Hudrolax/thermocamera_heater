// Watchdog
#include <avr/wdt.h>

#include <EEPROM.h>

int address = 0;                          // Переменная для хранения адреса

// librares for OLED 
#include <SPI.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

// librares for DS temperature sensor
#include <OneWire.h>
#include <DallasTemperature.h>

// librares for encoder
#include "GyverEncoder.h"
#include "TimerOne.h"

// If using software SPI (the default case): OLED
//#define OLED_MOSI  11   // D1
//#define OLED_CLK   12   // D0
//#define OLED_DC    9    // DC
//#define OLED_CS    8    // CS
//#define OLED_RESET 10   // RES

// init OLED
Adafruit_SSD1306 display(-1);

// init encoder
#define CLK 2 // pin D2
#define DT 3  //pin D3
#define SW 4  //pin D4
Encoder enc1(CLK, DT, SW);  // для работы c кнопкой

#define SolidRelay 6 // Pin D6 solid relay

#define HeaterDefPin 7 
#define PrinterDefPin 8 

// init DS sensor
#define ONE_WIRE_BUS 5 // pin DS sensor
// Setup a oneWire instance to communicate with any OneWire devices (not just Maxim/Dallas temperature ICs)
OneWire oneWire(ONE_WIRE_BUS);
// Pass our oneWire reference to Dallas Temperature. 
DallasTemperature sensors(&oneWire);
DeviceAddress insideThermometer = { 0x28, 0xFF, 0x0B, 0x7F, 0x93, 0x15, 0x01, 0x8B };

int s_temp = 25;
int tempC_old;
int tempC;

// 'ender', 100x25px
const unsigned char ender_logo [] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 
  0xff, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0x00, 0x00, 
  0x00, 0x01, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x78, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x06, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x03, 0xc0, 0x04, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 
  0xc0, 0x00, 0x00, 0x00, 0x00, 0x01, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x20, 0x0c, 
  0x78, 0x00, 0x7b, 0xc0, 0x1f, 0x80, 0x11, 0xc0, 0x00, 0x0f, 0x00, 0x60, 0x7d, 0xfc, 0x03, 0xff, 
  0xc0, 0x7f, 0xc1, 0xf7, 0xc0, 0x00, 0x1f, 0x01, 0xc0, 0xff, 0xfc, 0x0f, 0x0f, 0x81, 0xc3, 0xc7, 
  0xff, 0xc0, 0x00, 0x1f, 0xff, 0xc0, 0x7c, 0x3c, 0x1e, 0x07, 0x83, 0x03, 0xc1, 0xf3, 0x00, 0x00, 
  0x3f, 0xff, 0x80, 0xf0, 0x38, 0x3c, 0x0f, 0x07, 0xff, 0xc1, 0xe0, 0x00, 0x00, 0x3c, 0x03, 0x00, 
  0xf0, 0x78, 0x78, 0x0f, 0x0f, 0xff, 0xc3, 0xc0, 0x00, 0x00, 0x7c, 0x03, 0x01, 0xe0, 0x70, 0xf0, 
  0x1e, 0x1f, 0xff, 0x87, 0x80, 0x00, 0x00, 0x78, 0x02, 0x01, 0xc0, 0xf0, 0xf0, 0x1c, 0x3c, 0x00, 
  0x07, 0x80, 0x00, 0x00, 0xf8, 0x00, 0x03, 0xc1, 0xe1, 0xe0, 0x3c, 0x38, 0x00, 0x0f, 0x00, 0x00, 
  0x00, 0xf0, 0x00, 0xc3, 0xc1, 0xe1, 0xe0, 0x3c, 0x78, 0x03, 0x0f, 0x00, 0x00, 0x01, 0xf0, 0x01, 
  0x87, 0x83, 0xc3, 0xe0, 0x78, 0x78, 0x06, 0x1e, 0x00, 0x00, 0x03, 0xe0, 0x07, 0x87, 0x03, 0xc3, 
  0xe0, 0xf0, 0x7c, 0x1c, 0x1c, 0x00, 0x00, 0x07, 0xe0, 0x1f, 0x0f, 0x07, 0x83, 0xf1, 0xfc, 0x7f, 
  0xf8, 0x3c, 0x00, 0x00, 0x3f, 0xff, 0xfe, 0x3f, 0xdf, 0xc1, 0xff, 0xf0, 0x3f, 0xe1, 0xff, 0x00, 
  0x00, 0x3f, 0xff, 0xfc, 0x7f, 0x9f, 0xc0, 0xf9, 0x80, 0x1f, 0x01, 0xff, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00
};

// 'skull-with-fire-on-white-background-design-vector-22325524', 64x32px
const unsigned char flame [] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 
  0x00, 0x07, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x0f, 0x80, 0x00, 
  0x00, 0x4f, 0x80, 0x00, 0x00, 0x8f, 0xc8, 0x00, 0x00, 0x8f, 0xec, 0x00, 0x01, 0x8f, 0xee, 0x00, 
  0x01, 0xcf, 0xff, 0x00, 0x01, 0xcf, 0xff, 0x40, 0x09, 0xef, 0xff, 0xc0, 0x09, 0xff, 0xff, 0xe0, 
  0x0c, 0xff, 0xff, 0xe0, 0x1e, 0xff, 0x7f, 0xe0, 0x1f, 0x7f, 0x3f, 0xe8, 0x0f, 0xff, 0x1f, 0xe8, 
  0x0f, 0xfe, 0x1f, 0xf8, 0x2f, 0xfa, 0x0f, 0xdc, 0x6f, 0xe0, 0x07, 0xfc, 0x6f, 0xe0, 0x03, 0xfc, 
  0x77, 0xc0, 0x03, 0xfc, 0xff, 0xc0, 0x03, 0xfc, 0xff, 0x40, 0x01, 0xfc, 0xff, 0x00, 0x01, 0xfc, 
  0xfe, 0x00, 0x00, 0xfc, 0xfe, 0x00, 0x00, 0xfc, 0xfe, 0x00, 0x00, 0xf8, 0xff, 0x00, 0x00, 0xf8, 
  0x7f, 0x00, 0x00, 0xf8, 0x7f, 0x00, 0x00, 0xf0, 0x3f, 0x80, 0x00, 0xf0, 0x3f, 0x80, 0x01, 0xe0, 
  0x0f, 0xc0, 0x03, 0xc0, 0x07, 0xf8, 0x3f, 0x80, 0x01, 0xff, 0xfe, 0x00, 0x00, 0x1f, 0xf0, 0x00
};

void setup()   {                
  wdt_disable(); // бесполезная строка до которой не доходит выполнение при bootloop
  Serial.begin(9600);
  Serial.println("Setup..");

  s_temp=EEPROM.read(0);                   // Считать значение ячейки с адресом 0

  Serial.println("Begin sensors");
  sensors.begin();
  sensors.setResolution(insideThermometer, 9);

  Serial.println("Begin screen");
  display.begin(SSD1306_SWITCHCAPVCC, 0x3C);
  display.clearDisplay();
  display.drawBitmap(14, 8,  ender_logo, 100, 25, 1);
  display.display();

  Serial.println("Begin encoder");
  enc1.setType(TYPE1);
  Timer1.initialize(1000);            // установка таймера на каждые 1000 микросекунд (= 1 мс)
  Timer1.attachInterrupt(timerIsr);   // запуск таймера
 // attachInterrupt(0, isr, CHANGE);    // прерывание на 2 пине! CLK у энка

 Serial.println("Begin relay");
 pinMode(SolidRelay, OUTPUT);
 digitalWrite(SolidRelay, HIGH);
 
 pinMode(HeaterDefPin, OUTPUT);
 digitalWrite(HeaterDefPin, HIGH);
 
 pinMode(PrinterDefPin, OUTPUT);
 digitalWrite(PrinterDefPin, HIGH);
 
  Serial.println("Wait 1 sec..");
  delay(1000); // Задержка, чтобы было время перепрошить устройство в случае bootloop
  wdt_enable (WDTO_8S); // Для тестов не рекомендуется устанавливать значение менее 8 сек.
  Serial.println("Watchdog enabled.");
}

void timerIsr() {
  enc1.tick();  // отработка в прерывании
}

void loop()
{
  wdt_reset();
  
  sensors.requestTemperatures(); // Send the command to get temperatures
  tempC_old = tempC;
  tempC = sensors.getTempC(insideThermometer);
  if (tempC < -50) tempC = tempC_old;
  
  // read encoder
  if (enc1.isRight()) s_temp++;
  if (enc1.isLeft()) s_temp--;
  if (enc1.isFastR()) s_temp += 5;
  if (enc1.isFastL()) s_temp -= 5;
  if (s_temp>80) s_temp = 80;
  if (s_temp<25) s_temp = 25;
  if (enc1.isClick()){
    EEPROM.write(address,s_temp);
     // display REAL temp
    display.clearDisplay();
    display.setTextSize(3);
    display.setTextColor(WHITE);
    display.setCursor(15,10);
    display.print("saved");
    display.display();
    delay(1000);
  }
  
display.clearDisplay();
  if (tempC < s_temp){
    digitalWrite(SolidRelay, LOW);
    display.drawBitmap(90, 0,  flame, 30, 40, 1); // Выводим символ огня при нагреве
  }
    else{
      digitalWrite(SolidRelay, HIGH);
    }

 // Def OFF heater
 if (tempC < s_temp){
       digitalWrite(HeaterDefPin, HIGH);
  }
    else if (tempC > s_temp+5){
     digitalWrite(HeaterDefPin, LOW); 
    }   

  // display
    // display SET temp
  display.setTextSize(1);
  display.setTextColor(WHITE);
  display.setCursor(0,0);
  display.print("Set temp: ");
  display.print(s_temp);
  display.print(" C");

  // display REAL temp
  display.setTextSize(3);
  display.setTextColor(WHITE);
  display.setCursor(0,10);
  display.print(tempC);
  display.print(" C");
  
  display.display();
}
